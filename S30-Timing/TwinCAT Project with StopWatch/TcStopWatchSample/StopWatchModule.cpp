///////////////////////////////////////////////////////////////////////////////
// StopWatchModule.cpp
#include "TcPch.h"
#pragma hdrstop

#include "StopWatchModule.h"
#include "TcTimeConversion.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif
DEFINE_THIS_FILE()

///////////////////////////////////////////////////////////////////////////////
// CStopWatchModule
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Collection of interfaces implemented by module CStopWatchModule
BEGIN_INTERFACE_MAP(CStopWatchModule)
	INTERFACE_ENTRY_ITCOMOBJECT()
	INTERFACE_ENTRY(IID_ITcCyclic, ITcCyclic)
	INTERFACE_ENTRY(IID_ITcADI, ITcADI)
///<AutoGeneratedContent id="InterfaceMap">
	INTERFACE_ENTRY(IID_ITcCyclic, ITcCyclic)
///</AutoGeneratedContent>
END_INTERFACE_MAP()

IMPLEMENT_ITCOMOBJECT(CStopWatchModule)
IMPLEMENT_ITCOMOBJECT_SETSTATE_LOCKOP2(CStopWatchModule)
IMPLEMENT_ITCADI(CStopWatchModule)


///////////////////////////////////////////////////////////////////////////////
// Set parameters of CStopWatchModule 
BEGIN_SETOBJPARA_MAP(CStopWatchModule)
	SETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="SetObjectParameterMap">
	SETOBJPARA_ITFPTR(PID_Ctx_TaskOid, m_spCyclicCaller)
///</AutoGeneratedContent>
END_SETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get parameters of CStopWatchModule 
BEGIN_GETOBJPARA_MAP(CStopWatchModule)
	GETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="GetObjectParameterMap">
	GETOBJPARA_ITFPTR(PID_Ctx_TaskOid, m_spCyclicCaller)
///</AutoGeneratedContent>
END_GETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get data area members of CStopWatchModule
BEGIN_OBJDATAAREA_MAP(CStopWatchModule)
///<AutoGeneratedContent id="ObjectDataAreaMap">
	OBJDATAAREA_VALUE(0, m_Inputs)
	OBJDATAAREA_VALUE(1, m_Outputs)
	OBJDATAAREA_VALUE(3, m_InternalResults)
///</AutoGeneratedContent>
END_OBJDATAAREA_MAP()


///////////////////////////////////////////////////////////////////////////////
CStopWatchModule::CStopWatchModule()
	: m_counter(0)
{
	memset(&m_Inputs, 0, sizeof(m_Inputs)); 
	m_Inputs.nCount = 2000;
	memset(&m_Outputs, 0, sizeof(m_Outputs)); 
	memset(&m_InternalResults, 0, sizeof(m_InternalResults));

	memset(m_szPentiumTimeStart, 0, sizeof(m_szPentiumTimeStart));
	memset(m_szPentiumTimeStop, 0, sizeof(m_szPentiumTimeStop));
	memset(m_szTaskSysTime, 0, sizeof(m_szTaskSysTime));
	memset(m_szTaskDcTime, 0, sizeof(m_szTaskDcTime));
	memset(m_szTaskCycleTime, 0, sizeof(m_szTaskCycleTime));
	memset(m_szTaskCpuAccountForAnotherPi, 0, sizeof(m_szTaskCpuAccountForAnotherPi));
	memset(m_szPentiumTimeDiffForPi, 0, sizeof(m_szPentiumTimeDiffForPi));
}

///////////////////////////////////////////////////////////////////////////////
CStopWatchModule::~CStopWatchModule() 
{
}


///////////////////////////////////////////////////////////////////////////////
// State Transitions 
///////////////////////////////////////////////////////////////////////////////
IMPLEMENT_ITCOMOBJECT_SETOBJSTATE_IP_PI(CStopWatchModule)

///////////////////////////////////////////////////////////////////////////////
// State transition from PREOP to SAFEOP
//
// Initialize input parameters 
// Allocate memory
HRESULT CStopWatchModule::SetObjStatePS(PTComInitDataHdr pInitData)
{
	HRESULT hr = S_OK;
	IMPLEMENT_ITCOMOBJECT_EVALUATE_INITDATA(pInitData);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to OP
//
// Register with other TwinCAT objects
HRESULT CStopWatchModule::SetObjStateSO()
{
	HRESULT hr = S_OK;

	// TODO: Add any additional initialization
	// get reference to TC-RTime-Instance
	m_spRTime.SetOID(OID_TCRTIME_CTRL);
	hr = FAILED(hr) ? hr : m_spSrv->TcQuerySmartObjectInterface(m_spRTime);

	// If following call is successful the CycleUpdate method will be called, 
	// eventually even before method has been left.
	hr = FAILED(hr) ? hr : AddModuleToCaller(); 
	// Cleanup if transition failed at some stage
	if ( FAILED(hr) )
	{
		RemoveModuleFromCaller(); 
		m_spRTime = NULL;
	}
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from OP to SAFEOP
HRESULT CStopWatchModule::SetObjStateOS()
{
	HRESULT hr = S_OK;
	RemoveModuleFromCaller(); 
	m_spRTime = NULL;
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to PREOP
HRESULT CStopWatchModule::SetObjStateSP()
{
	HRESULT hr = S_OK;
	return hr;
}

#define TIMESTAMPSTR "%04d/%02d/%02d %02d:%02d:%02d.%03d"
#define TIMESTAMPPARM(st) st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds

///////////////////////////////////////////////////////////
// ITcCyclic
///<AutoGeneratedContent id="ImplementationOf_ITcCyclic">
HRESULT CStopWatchModule::CycleUpdate(ITcTask* ipTask, ITcUnknown* ipCaller, ULONG_PTR context)
{
	HRESULT hr = S_OK;
	m_counter++;

	// UTC at time of call in 100 ns intervals since 1.1.1601
	hr = FAILED(hr) ? hr : m_spRTime->GetCurPentiumTime(&m_Outputs.PentiumTimeStart); 

	m_InternalResults.Pi = ComputePi(m_Inputs.nCount);

	hr = FAILED(hr) ? hr : m_spRTime->GetCurPentiumTime(&m_Outputs.PentiumTimeStop); 

	m_Outputs.PentiumTimeDiff = m_Outputs.PentiumTimeStop - m_Outputs.PentiumTimeStart;

	// CPU account in 100 ns interval
	ITcRTimeTaskPtr spRTimeTask = ipTask;
	if (spRTimeTask != NULL)
	{
		ULONG nStart = 0;
		hr = FAILED(hr) ? hr : spRTimeTask->GetCpuAccount(&nStart);

		m_InternalResults.AnotherPi = ComputePi(m_Inputs.nCount);

		ULONG nStop = 0;
		hr = FAILED(hr) ? hr : spRTimeTask->GetCpuAccount(&nStop);

		m_Outputs.TaskCpuAccountForAnotherPi = nStop - nStart;
	}

	// UTC at "begin of task" in 100 ns intervals since 1.1.1601
	hr = FAILED(hr) ? hr : ipTask->GetCurrentSysTime(&m_Outputs.TaskSysTime); 

	// Distributed clock timestamp at "begin of task" (independent from read time within task cycle)
	hr = FAILED(hr) ? hr : ipTask->GetCurrentDcTime(&m_Outputs.TaskDcTime );
	
	// Cylce time in nanoseconds, i.e. time between "begin of task" to next "begin of task" (configured information)
	hr = FAILED(hr) ? hr : ipTask->GetCycleTime(&m_Outputs.TaskCycleTime); 

	////////////////////////////////////////////////////////////////////////////
	// convert time info to string
	////////////////////////////////////////////////////////////////////////////
	SYSTEMTIME stPentiumTimeStart;
	SYSTEMTIME stPentiumTimeStop;
	SYSTEMTIME stTaskSysTime;

	TcFileTimeToSystemTime(m_Outputs.PentiumTimeStart, &stPentiumTimeStart); 
	TcFileTimeToSystemTime(m_Outputs.PentiumTimeStop, &stPentiumTimeStop); 
	TcFileTimeToSystemTime(m_Outputs.TaskSysTime, &stTaskSysTime); 

	sprintf(m_szPentiumTimeStart, TIMESTAMPSTR, TIMESTAMPPARM(stPentiumTimeStart));
	sprintf(m_szPentiumTimeStop, TIMESTAMPSTR, TIMESTAMPPARM(stPentiumTimeStop));
	sprintf(m_szTaskSysTime, TIMESTAMPSTR, TIMESTAMPPARM(stTaskSysTime));

	sprintf(m_szTaskCycleTime, "%d ms", m_Outputs.TaskCycleTime/1000000);
	sprintf(m_szTaskCpuAccountForAnotherPi, "%d us", m_Outputs.TaskCpuAccountForAnotherPi/10);
	sprintf(m_szPentiumTimeDiffForPi, "%d us", m_Outputs.PentiumTimeDiff/10);

	sprintf(m_szTaskDcTime, "%u ns", m_Outputs.TaskDcTime);
	return hr;
}
///</AutoGeneratedContent>


double CStopWatchModule::ComputePi(ULONG nCount)
{
	double value = 0.0; 
	double sum = 0.0;
	int sign = -1;
	for (ULONG idx = 0; idx<nCount; ++idx)
	{
		sign = -sign;
		value = (double)sign/(double)(2*idx+1);
		sum = sum + value;
	}
	sum *= 4.0;
	return sum;
}


///////////////////////////////////////////////////////////////////////////////
HRESULT CStopWatchModule::AddModuleToCaller()
{
	HRESULT hr = S_OK;
	if ( m_spCyclicCaller.HasOID() )
	{
		if ( SUCCEEDED_DBG(hr = m_spSrv->TcQuerySmartObjectInterface(m_spCyclicCaller)) )
		{
			if ( FAILED(hr = m_spCyclicCaller->AddModule(m_spCyclicCaller, THIS_CAST(ITcCyclic))) )
			{
				m_spCyclicCaller = NULL;
			}
		}
	}
	else
	{
		hr = ADS_E_INVALIDOBJID; 
		SUCCEEDED_DBGT(hr, "Invalid OID specified for caller task");
	}
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
VOID CStopWatchModule::RemoveModuleFromCaller()
{
	if ( m_spCyclicCaller )
	{
		m_spCyclicCaller->RemoveModule(m_spCyclicCaller);
	}
	m_spCyclicCaller	= NULL;
}


